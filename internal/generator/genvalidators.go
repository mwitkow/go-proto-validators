// Copyright Improbable Worlds Ltd. All Rights Reserved.
// See LICENSE for licensing terms.

package generator

import (
	"fmt"
	"reflect"
	"strconv"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"

	validator "github.com/mwitkow/go-proto-validators"
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Messages) == 0 {
		return nil // if there are no messages then we should not generate anything.
	}

	filename := file.GeneratedFilenamePrefix + ".validator.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-govalidators. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	generateFileContent(gen, file, g)
	return g
}

var (
	errorsPkg    = protogen.GoImportPath("errors")
	fmtPkg       = protogen.GoImportPath("fmt")
	regepxPkg    = protogen.GoImportPath("regexp")
	validatorPkg = protogen.GoImportPath("github.com/mwitkow/go-proto-validators")
)

func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	if !validateFileValidators(gen, file) {
		return
	}

	for _, msg := range file.Messages {
		generateMessageValidators(file, msg, g)
	}
}

func validateFileValidators(gen *protogen.Plugin, file *protogen.File) bool {
	isValid := true
	for _, msg := range file.Messages {
		isValid = isValid && validateMessageValidators(gen, msg)
	}
	return isValid
}

func validateMessageValidators(gen *protogen.Plugin, msg *protogen.Message) bool {
	if msg.Desc.IsMapEntry() {
		return true
	}

	// Note that we are not validating one-of validators as there's nothing to validate about them.
	isValid := true
	for _, field := range msg.Fields {
		isValid = isValid && validateAllowedValidators(gen, field) && validateConflictingValidators(gen, field)
	}

	for _, childMsg := range msg.Messages {
		isValid = isValid && validateMessageValidators(gen, childMsg)
	}

	return isValid
}

func validateAllowedValidators(gen *protogen.Plugin, field *protogen.Field) bool {
	val, ok := fieldValidator(field.Desc.Options())
	if !ok {
		return true
	}

	isValid := true
	v := reflect.ValueOf(val).Elem()
	for idx := 0; idx < v.NumField(); idx++ {
		if v.Type().Field(idx).Type.Kind() != reflect.Ptr || v.Field(idx).IsNil() {
			continue
		}

		fieldName := v.Type().Field(idx).Name

		var allowed bool
		for _, allowedValidator := range allowedValidators(field) {
			if fieldName == validatorTypeToString[allowedValidator] {
				allowed = true
				break
			}
		}
		if !allowed {
			gen.Error(fmt.Errorf("field %q cannot have a validator of type %q", field.Desc.Name(), fieldName))
			isValid = false
		}
	}
	return isValid
}

func validateConflictingValidators(gen *protogen.Plugin, field *protogen.Field) bool {
	val, ok := fieldValidator(field.Desc.Options())
	if !ok {
		return true
	}

	isValid := true

	// String-based validators.
	valCount := 0
	if val.LengthEq != nil || val.LengthGt != nil || val.LengthLt != nil {
		valCount++
	}
	if val.Regex != nil {
		valCount++
	}
	if val.StringNotEmpty != nil {
		valCount++
	}
	if val.UuidVer != nil {
		if val.GetUuidVer() < 0 || val.GetUuidVer() > 5 {
			gen.Error(fmt.Errorf("field %q should have a uuid version value between 0 and 5", field.Desc.Name()))
			isValid = false
		}
		valCount++
	}
	if valCount > 1 {
		gen.Error(fmt.Errorf(
			"field %q can not have more than one of either a regex, string_not_empty, uuid_ver or any of the length_* validators",
			field.Desc.FullName(),
		))
		isValid = false
	}

	// Integer-based validators.
	if val.IntGt != nil && val.IntLt != nil && val.GetIntGt() > val.GetIntLt()-1 {
		gen.Error(fmt.Errorf(
			"field %q has conflicting validators as its value can never be both greater than %d and lower than %d",
			field.Desc.FullName(),
			val.GetIntGt(),
			val.GetIntLt(),
		))
		isValid = false
	}

	// Float-based validators.
	if val.FloatEpsilon != nil && val.FloatGt == nil && val.FloatGte == nil && val.FloatLt == nil && val.FloatLte == nil {
		gen.Error(fmt.Errorf("field %q can not have float_epsilon but no other float-value validator", field.Desc.Name()))
		isValid = false
	}
	if val.FloatGt != nil && val.FloatGte != nil {
		gen.Error(fmt.Errorf("field %q has redundant float_gt and float_gte validators, only use one", field.Desc.Name()))
		isValid = false
	}
	if val.FloatLt != nil && val.FloatLte != nil {
		gen.Error(fmt.Errorf("field %q has redundant float_lt and float_lte validators, only use one", field.Desc.Name()))
		isValid = false
	}
	switch {
	case val.FloatGt != nil && val.FloatLt != nil:
		if val.GetFloatGt() >= val.GetFloatLt() {
			gen.Error(fmt.Errorf(
				"field %q has conflicting validators as its value can never be both greater than %f and lower than %f",
				field.Desc.Name(),
				val.GetFloatGt(), val.GetFloatLt(),
			))
		}
	case val.FloatGt != nil && val.FloatLte != nil:
		if val.GetFloatGt() >= val.GetFloatLte() {
			gen.Error(fmt.Errorf(
				"field %q has conflicting validators as its value can never be both greater than %f and lower than or equal to %f",
				field.Desc.Name(),
				val.GetFloatGt(), val.GetFloatLte(),
			))
		}
	case val.FloatGte != nil && val.FloatLt != nil:
		if val.GetFloatGte() >= val.GetFloatLt() {
			gen.Error(fmt.Errorf(
				"field %q has conflicting validators as its value can never be both greater than or equal to %f and lower than %f",
				field.Desc.Name(),
				val.GetFloatGte(), val.GetFloatLt(),
			))
		}
	case val.FloatGte != nil && val.FloatLte != nil:
		if val.GetFloatGte() > val.GetFloatLte() {
			gen.Error(fmt.Errorf(
				"field %q has conflicting validators as its value can never be both greater than or equal to %f and lower than or equal to %f",
				field.Desc.Name(),
				val.GetFloatGte(), val.GetFloatLte(),
			))
		}
	}

	// Length-based validators.
	if val.LengthEq != nil && (val.LengthGt != nil || val.LengthLt != nil) {
		gen.Error(fmt.Errorf("field %q can not have both length_eq and any of length_gt or length_lt as validators", field.Desc.FullName()))
		isValid = false
	}
	if val.LengthGt != nil && val.LengthLt != nil && (val.GetLengthGt() > val.GetLengthLt()-1) {
		gen.Error(fmt.Errorf(
			"field %q has conflicting validators as its length can not be both greater than %d and lower than %d",
			field.Desc.Name(),
			val.GetLengthGt(),
			val.GetLengthLt(),
		))
		isValid = false
	}
	if val.RepeatedCountMax != nil && val.RepeatedCountMin != nil && (val.GetRepeatedCountMax() < val.GetRepeatedCountMin()) {
		gen.Error(fmt.Errorf(
			"field %q has conflicting validators as it can't have both at most %d elements and at least %d elements",
			field.Desc.Name(),
			val.GetRepeatedCountMax(),
			val.GetRepeatedCountMin(),
		))
		isValid = false
	}

	return isValid
}

func generateMessageValidators(file *protogen.File, msg *protogen.Message, g *protogen.GeneratedFile) {
	if msg.Desc.IsMapEntry() {
		return
	}

	for _, childMsg := range msg.Messages {
		generateMessageValidators(file, childMsg, g)
	}

	generateRegexpVars(msg, g)

	g.P("func (m *", msg.GoIdent.GoName, ") Validate() error {")
	defer func() {
		g.P("return nil")
		g.P("}")
		g.P()
	}()

	for _, oneOf := range msg.Oneofs {
		val, ok := oneOfValidator(oneOf.Desc.Options())
		if !ok || !val.GetRequired() {
			continue
		}

		g.P("if m.Get", oneOf.GoName, "() == nil {")
		g.P("return ", validatorPkg.Ident("FieldError"), `("`, oneOf.GoName, `", `, errorsPkg.Ident("New"), `("one of the fields must be set"))`)
		g.P("}")
		g.P()
	}

	for _, field := range msg.Fields {
		generateFieldValidators(file, field, g)
	}
}

const uuidPattern = "^[a-fA-F0-9]{8}-" +
	"[a-fA-F0-9]{4}-" +
	"[%s][a-fA-F0-9]{3}-" +
	"[8|9|aA|bB][a-fA-F0-9]{3}-" +
	"[a-fA-F0-9]{12}$"

func generateRegexpVars(msg *protogen.Message, g *protogen.GeneratedFile) {
	var hasRegexVars bool
	for _, field := range msg.Fields {
		val, ok := fieldValidator(field.Desc.Options())
		if !ok || (val.Regex == nil && val.UuidVer == nil) {
			continue
		}

		pattern := val.GetRegex()
		if val.UuidVer != nil {
			pattern = fmt.Sprintf(uuidPattern, strconv.Itoa(int(val.GetUuidVer())))
			if val.GetUuidVer() == 0 {
				pattern = fmt.Sprintf(uuidPattern, "1-5")
			}
		}
		g.P("var ", regexpVarName(field), " = ", regepxPkg.Ident("MustCompile"), "(`", pattern, "`)")
		hasRegexVars = true
	}
	if hasRegexVars {
		g.P()
	}
}

func regexpVarName(field *protogen.Field) string {
	return field.Parent.GoIdent.GoName + field.GoName + "RE"
}

func generateFieldValidators(file *protogen.File, field *protogen.Field, g *protogen.GeneratedFile) {
	val, ok := fieldValidator(field.Desc.Options())
	if !ok && field.Message == nil {
		return
	}

	if file.Desc.Syntax().String() == "proto2" && field.Desc.Cardinality() == protoreflect.Optional {
		g.P("if m.", field.GoName, " != nil {")
	}
	if field.Oneof != nil {
		g.P("if _, ok := m.", field.Oneof.GoName, ".(*", field.GoIdent, "); ok {")
	}

	iterate := field.Desc.Cardinality() == protoreflect.Repeated && (hasValueConstraints(val) || field.Message != nil)

	valueRef := fmt.Sprintf("m.Get%s()", field.GoName)
	if val != nil && val.RepeatedCountMax != nil {
		g.P("if len(", valueRef, ") > ", val.GetRepeatedCountMax(), " {")
		printFieldErr(g, field,
			fmtPkg.Ident("Errorf"),
			`("`,
			field.Desc.Name(),
			" has %d elements whereas a maximum of ",
			val.GetRepeatedCountMax(),
			` is allowed", len(`,
			valueRef,
			"))",
		)
		g.P("}")
		g.P()
	}
	if val != nil && val.RepeatedCountMin != nil {
		g.P("if len(", valueRef, ") < ", val.GetRepeatedCountMin(), " {")
		printFieldErr(g, field,
			fmtPkg.Ident("Errorf"),
			`("`,
			field.Desc.Name(),
			" has %d elements whereas a minimum of ",
			val.GetRepeatedCountMin(),
			` is required", len(`,
			valueRef,
			"))",
		)
		g.P("}")
		g.P()
	}

	if iterate {
		if field.Desc.IsMap() && (field.Message.Desc.Fields().ByNumber(2).Kind() != protoreflect.MessageKind && !hasValueConstraints(val)) {
			return
		}

		g.P("for _, item := range ", valueRef, " {")
		valueRef = "item"
	}

	generateValueConstraints(field, valueRef, g)

	if iterate {
		g.P("}")
	}
	if field.Oneof != nil {
		g.P("}")
	}
	if file.Desc.Syntax().String() == "proto2" && field.Desc.Cardinality() == protoreflect.Optional {
		g.P("}")
	}
	g.P()
}

func generateValueConstraints(field *protogen.Field, valueRef string, g *protogen.GeneratedFile) {
	if field.Message != nil && (!field.Desc.IsMap() || field.Message.Desc.Fields().ByNumber(2).Kind() == protoreflect.MessageKind) {
		g.P("if ", valueRef, " != nil {")
		g.P("if err := ", validatorPkg.Ident("CallValidatorIfExists"), "(", valueRef, "); err != nil {")
		printFieldErr(g, field, "err")
		g.P("}")
		g.P("}")
	}

	val, ok := fieldValidator(field.Desc.Options())
	if !ok {
		return
	}

	if val.FloatGt != nil {
		l := val.GetFloatGt() - val.GetFloatEpsilon()
		g.P("if ", valueRef, " <= ", l, " {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), " is not greater than ", l, `")`)
		g.P("}")
	} else if val.FloatGte != nil {
		l := val.GetFloatGte() - val.GetFloatEpsilon()
		g.P("if ", valueRef, " < ", l, " {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), " is not greater than or equal to ", l, `")`)
		g.P("}")
	}

	if val.FloatLt != nil {
		l := val.GetFloatLt() + val.GetFloatEpsilon()
		g.P("if ", valueRef, " >= ", l, " {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), " is not smaller than ", l, `")`)
		g.P("}")
	} else if val.FloatLte != nil {
		l := val.GetFloatLte() + val.GetFloatEpsilon()
		g.P("if ", valueRef, " > ", l, " {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), " is not smaller than or equal to ", l, `")`)
		g.P("}")
	}

	if val.IntGt != nil {
		l := val.GetIntGt()
		g.P("if ", valueRef, " <=", l, " {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), " is not greater than ", l, `")`)
		g.P("}")
	}
	if val.IntLt != nil {
		l := val.GetIntLt()
		g.P("if ", valueRef, " >=", l, " {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), " is not smaller than ", l, `")`)
		g.P("}")
	}

	if val.IsInEnum != nil {
		g.P("if _, ok := ", field.Enum.GoIdent.GoName, "_name[int32(", valueRef, ")]; !ok {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), ` should correspond to a valid enum value")`)
		g.P("}")
	}

	if val.LengthEq != nil {
		g.P("if len(", valueRef, ") != ", val.GetLengthEq(), " {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), " should be of length ", val.GetLengthEq(), `")`)
		g.P("}")
	}
	if val.LengthGt != nil {
		g.P("if len(", valueRef, ") <= ", val.GetLengthGt(), " {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), " should have a length greater than ", val.GetLengthGt(), `")`)
		g.P("}")
	}
	if val.LengthLt != nil {
		g.P("if len(", valueRef, ") >= ", val.GetLengthLt(), " {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), " should have a length smaller than ", val.GetLengthLt(), `")`)
		g.P("}")
	}

	if val.GetMsgExists() {
		g.P("if ", valueRef, " == nil {")
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), ` should be set")`)
		g.P("}")
	}

	if val.Regex != nil {
		g.P("if !", regexpVarName(field), ".MatchString(string(", valueRef, ")) {")
		printFieldErr(g, field, errorsPkg.Ident("New"), "(`", field.Desc.Name(), " should match regular expression ", strconv.Quote(val.GetRegex()), "`)")
		g.P("}")
	}

	if val.StringNotEmpty != nil {
		g.P("if string(", valueRef, `) == "" {`)
		printFieldErr(g, field, errorsPkg.Ident("New"), `("`, field.Desc.Name(), ` should not be empty")`)
		g.P("}")
	}

	if val.UuidVer != nil {
		g.P("if !", regexpVarName(field), ".MatchString(string(", valueRef, ")) {")
		printFieldErr(g, field,
			errorsPkg.Ident("New"),
			`("`,
			field.Desc.Name(),
			" should match regular expression '",
			fmt.Sprintf(uuidPattern, strconv.Itoa(int(val.GetUuidVer()))),
			`'")`,
		)
		g.P("}")
	}
}

func printFieldErr(g *protogen.GeneratedFile, field *protogen.Field, errorString ...interface{}) {
	val, ok := fieldValidator(field.Desc.Options())
	if ok && val.HumanError != nil {
		errorString = []interface{}{errorsPkg.Ident("New"), `("`, val.GetHumanError(), `")`}
	}
	g.P(append(append([]interface{}{"return ", validatorPkg.Ident("FieldError"), `("`, field.GoName, `", `}, errorString...), ")")...)
}

func fieldValidator(fieldOptions protoreflect.ProtoMessage) (*validator.FieldValidator, bool) {
	ext := extractValidator(fieldOptions, validator.E_Field)
	if ext == nil {
		return nil, false
	}
	val, ok := ext.(*validator.FieldValidator)
	return val, ok
}

func oneOfValidator(fieldOptions protoreflect.ProtoMessage) (*validator.OneofValidator, bool) {
	ext := extractValidator(fieldOptions, validator.E_Oneof)
	if ext == nil {
		return nil, false
	}
	val, ok := ext.(*validator.OneofValidator)
	return val, ok
}

func extractValidator(fieldOptions protoreflect.ProtoMessage, extType protoreflect.ExtensionType) interface{} {
	// The supplied interface might be empty but will still not be comparible to a nil pointer.
	// Hence we assert that the proto message is atleast valid before trying to extract our
	// extension field.
	if !fieldOptions.ProtoReflect().IsValid() {
		return nil
	} else if !proto.HasExtension(fieldOptions, extType) {
		return nil
	}
	return proto.GetExtension(fieldOptions, extType)
}

func hasValueConstraints(val *validator.FieldValidator) bool {
	if val == nil {
		return false
	}
	return val.FloatEpsilon != nil ||
		val.FloatGt != nil ||
		val.FloatGte != nil ||
		val.FloatLt != nil ||
		val.FloatLte != nil ||
		val.IntGt != nil ||
		val.IntLt != nil ||
		val.IsInEnum != nil ||
		val.LengthEq != nil ||
		val.LengthGt != nil ||
		val.LengthLt != nil ||
		val.MsgExists != nil ||
		val.Regex != nil ||
		val.StringNotEmpty != nil ||
		val.UuidVer != nil
}

func allowedValidators(field *protogen.Field) []validatorType {
	vals := []validatorType{humanErrorValidator}

	if field.Desc.Cardinality() == protoreflect.Repeated {
		vals = append(vals, repeatedCountMaxValidator, repeatedCountMinValidator)
	}

	switch field.Desc.Kind() {
	case protoreflect.BytesKind, protoreflect.StringKind:
		vals = append(
			vals,
			lengthEqValidator,
			lengthGtValidator,
			lengthLtValidator,
			stringNotEmptyValidator,
			uuidVerValidator,
			regexValidator,
		)
	case protoreflect.DoubleKind, protoreflect.Fixed32Kind, protoreflect.Fixed64Kind,
		protoreflect.FloatKind, protoreflect.Sfixed32Kind, protoreflect.Sfixed64Kind:
		vals = append(
			vals,
			floatEpsilonValidator,
			floatGtValidator,
			floatGteValidator,
			floatLtValidator,
			floatLteValidator,
		)
	case protoreflect.EnumKind:
		vals = append(
			vals,
			isInEnumValidator,
		)
	case protoreflect.Int32Kind, protoreflect.Int64Kind, protoreflect.Sint32Kind, protoreflect.Sint64Kind,
		protoreflect.Uint32Kind, protoreflect.Uint64Kind:
		vals = append(
			vals,
			intGtValidator,
			intLtValidator,
		)
	case protoreflect.MessageKind:
		if field.Desc.IsMap() && field.Message.Desc.Fields().ByNumber(2).Kind() != protoreflect.MessageKind {
			return allowedValidators(field.Message.Fields[1])
		}
		vals = append(
			vals, msgExistsValidator,
		)
	}
	return vals
}
